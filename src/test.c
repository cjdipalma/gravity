/*
 * Auto Generated by The Gravity Compiler - Fri Feb 21 03:20:44 2020
 * Copyright (C) Tony Givargis, 2019-2020
 */

#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <math.h>
#include "test.h"

static void _initialize_(char *m_) {
  { /* RANDOM */
    float r, *z = (float *)( m_ + 0 );
    uint32_t i;
    for (i=0; i<78400; ++i) {
      r = (float)rand() / RAND_MAX;
      z[i] = -0.006787 + r * 0.013575;
    }
  }

  { /* CLEAR */
    memset(m_ + 313600, 0, 100 * sizeof (float));
  }

  { /* RANDOM */
    float r, *z = (float *)( m_ + 314000 );
    uint32_t i;
    for (i=0; i<10000; ++i) {
      r = (float)rand() / RAND_MAX;
      z[i] = -0.030000 + r * 0.060000;
    }
  }

  { /* CLEAR */
    memset(m_ + 354000, 0, 100 * sizeof (float));
  }

  { /* RANDOM */
    float r, *z = (float *)( m_ + 354400 );
    uint32_t i;
    for (i=0; i<1000; ++i) {
      r = (float)rand() / RAND_MAX;
      z[i] = -0.054545 + r * 0.109091;
    }
  }

  { /* CLEAR */
    memset(m_ + 358400, 0, 10 * sizeof (float));
  }

  { /* RET */
    return;
  }
}

static float *_activate_(char *m_, const float *x_) {
  { /* COPYX */
    memcpy(m_ + 716880, x_, 784 * sizeof (float));
  }

  { /* MAC1 */
    float *z = (float *)( m_ + 720016 );
    const float *A = (const float *)( m_ + 0 );
    const float *B = (const float *)( m_ + 716880 );
    uint32_t i, j;
    for (i=0; i<100; ++i) {
      z[i] = 0.0;
      for (j=0; j<784; ++j) {
        z[i] += A[i * 784 + j] * B[j];
      }
    }
  }

  { /* ADD */
    float *za = (float *)( m_ + 720016 );
    const float *B = (const float *)( m_ + 313600 );
    uint32_t i;
    for (i=0; i<100; ++i) {
      za[i] += B[i];
    }
  }

  { /* RELU */
    float *za = (float *)( m_ + 720016 );
    uint32_t i;
    for (i=0; i<100; ++i) {
      if (0.0 >= za[i]) {
        za[i] = 0.0;
      }
    }
  }

  { /* MAC1 */
    float *z = (float *)( m_ + 720816 );
    const float *A = (const float *)( m_ + 314000 );
    const float *B = (const float *)( m_ + 720016 );
    uint32_t i, j;
    for (i=0; i<100; ++i) {
      z[i] = 0.0;
      for (j=0; j<100; ++j) {
        z[i] += A[i * 100 + j] * B[j];
      }
    }
  }

  { /* ADD */
    float *za = (float *)( m_ + 720816 );
    const float *B = (const float *)( m_ + 354000 );
    uint32_t i;
    for (i=0; i<100; ++i) {
      za[i] += B[i];
    }
  }

  { /* RELU */
    float *za = (float *)( m_ + 720816 );
    uint32_t i;
    for (i=0; i<100; ++i) {
      if (0.0 >= za[i]) {
        za[i] = 0.0;
      }
    }
  }

  { /* MAC1 */
    float *z = (float *)( m_ + 721616 );
    const float *A = (const float *)( m_ + 354400 );
    const float *B = (const float *)( m_ + 720816 );
    uint32_t i, j;
    for (i=0; i<10; ++i) {
      z[i] = 0.0;
      for (j=0; j<100; ++j) {
        z[i] += A[i * 100 + j] * B[j];
      }
    }
  }

  { /* ADD */
    float *za = (float *)( m_ + 721616 );
    const float *B = (const float *)( m_ + 358400 );
    uint32_t i;
    for (i=0; i<10; ++i) {
      za[i] += B[i];
    }
  }

  { /* SOFTMAX */
    float *za = (float *)( m_ + 721616 );
    float max=za[0], sum=0.0;
    uint32_t i;
    for (i=1; i<10; ++i) {
      if (max < za[i]) {
        max = za[i];
      }
    }
    for (i=0; i<10; ++i) {
      za[i] -= max;
      sum += (float)exp(za[i]);
    }
    for (i=0; i<10; ++i) {
      za[i] = (float)exp(za[i]) / sum;
    }
  }

  { /* RETARG */
    return (float *)( m_ + 721616 );
  }
}

static void _backprop_(char *m_, const float *y_) {
  { /* SUBY */
    float *z = (float *)( m_ + 721656 );
    const float *A = (const float *)( m_ + 721616 );
    uint32_t i;
    for (i=0; i<10; ++i) {
      z[i] = A[i] - y_[i];
    }
  }

  { /* MAC2 */
    float *z = (float *)( m_ + 721216 );
    const float *A = (const float *)( m_ + 354400 );
    const float *B = (const float *)( m_ + 721656 );
    uint32_t i, j;
    for (i=0; i<100; ++i) {
      z[i] = 0.0;
      for (j=0; j<10; ++j) {
        z[i] += A[j * 100 + i] * B[j];
      }
    }
  }

  { /* RELUD */
    float *za = (float *)( m_ + 721216 );
    const float *B = (const float *)( m_ + 720816 );
    uint32_t i;
    for (i=0; i<100; ++i) {
      if (0.0 >= B[i]) {
        za[i] = 0.0;
      }
    }
  }

  { /* MAC2 */
    float *z = (float *)( m_ + 720416 );
    const float *A = (const float *)( m_ + 314000 );
    const float *B = (const float *)( m_ + 721216 );
    uint32_t i, j;
    for (i=0; i<100; ++i) {
      z[i] = 0.0;
      for (j=0; j<100; ++j) {
        z[i] += A[j * 100 + i] * B[j];
      }
    }
  }

  { /* RELUD */
    float *za = (float *)( m_ + 720416 );
    const float *B = (const float *)( m_ + 720016 );
    uint32_t i;
    for (i=0; i<100; ++i) {
      if (0.0 >= B[i]) {
        za[i] = 0.0;
      }
    }
  }

  { /* ADD */
    float *za = (float *)( m_ + 672040 );
    const float *B = (const float *)( m_ + 720416 );
    uint32_t i;
    for (i=0; i<100; ++i) {
      za[i] += B[i];
    }
  }

  { /* MAC3 */
    float *za = (float *)( m_ + 358440 );
    const float *B = (const float *)( m_ + 720416 );
    const float *C = (const float *)( m_ + 716880 );
    uint32_t i, j;
    for (i=0; i<100; ++i) {
      for (j=0; j<784; ++j) {
        za[i * 784 + j] += B[i] * C[j];
      }
    }
  }

  { /* ADD */
    float *za = (float *)( m_ + 712440 );
    const float *B = (const float *)( m_ + 721216 );
    uint32_t i;
    for (i=0; i<100; ++i) {
      za[i] += B[i];
    }
  }

  { /* MAC3 */
    float *za = (float *)( m_ + 672440 );
    const float *B = (const float *)( m_ + 721216 );
    const float *C = (const float *)( m_ + 720016 );
    uint32_t i, j;
    for (i=0; i<100; ++i) {
      for (j=0; j<100; ++j) {
        za[i * 100 + j] += B[i] * C[j];
      }
    }
  }

  { /* ADD */
    float *za = (float *)( m_ + 716840 );
    const float *B = (const float *)( m_ + 721656 );
    uint32_t i;
    for (i=0; i<10; ++i) {
      za[i] += B[i];
    }
  }

  { /* MAC3 */
    float *za = (float *)( m_ + 712840 );
    const float *B = (const float *)( m_ + 721656 );
    const float *C = (const float *)( m_ + 720816 );
    uint32_t i, j;
    for (i=0; i<10; ++i) {
      for (j=0; j<100; ++j) {
        za[i * 100 + j] += B[i] * C[j];
      }
    }
  }

  { /* RET */
    return;
  }
}

static void _train_(char *m_, const float *x_, const float *y_) {
  { /* CLEAR */
    memset(m_ + 358440, 0, 89610 * sizeof (float));
  }

  { /* BATCHLOOP */
    uint32_t i;
    for (i=0; i<8; ++i) {
        _activate_(m_, x_ + i * 784);
        _backprop_(m_, y_ + i * 10);
    }
  }

  { /* MAC4 */
    float *za = (float *)( m_ + 0 );
    const float *B = (const float *)( m_ + 358440 );
    uint32_t i;
    for (i=0; i<78400; ++i) {
      za[i] += B[i] * -0.012500;
    }
  }

  { /* MAC4 */
    float *za = (float *)( m_ + 313600 );
    const float *B = (const float *)( m_ + 672040 );
    uint32_t i;
    for (i=0; i<100; ++i) {
      za[i] += B[i] * -0.012500;
    }
  }

  { /* MAC4 */
    float *za = (float *)( m_ + 314000 );
    const float *B = (const float *)( m_ + 672440 );
    uint32_t i;
    for (i=0; i<10000; ++i) {
      za[i] += B[i] * -0.012500;
    }
  }

  { /* MAC4 */
    float *za = (float *)( m_ + 354000 );
    const float *B = (const float *)( m_ + 712440 );
    uint32_t i;
    for (i=0; i<100; ++i) {
      za[i] += B[i] * -0.012500;
    }
  }

  { /* MAC4 */
    float *za = (float *)( m_ + 354400 );
    const float *B = (const float *)( m_ + 712840 );
    uint32_t i;
    for (i=0; i<1000; ++i) {
      za[i] += B[i] * -0.012500;
    }
  }

  { /* MAC4 */
    float *za = (float *)( m_ + 358400 );
    const float *B = (const float *)( m_ + 716840 );
    uint32_t i;
    for (i=0; i<10; ++i) {
      za[i] += B[i] * -0.012500;
    }
  }

  { /* RET */
    return;
  }
}

int test_version(void) {
  return 10;
}

size_t test_memory_size(void) {
  return 721696;
}

size_t test_memory_hard(void) {
  return 358440;
}

void test_initialize(void *m) {
  _initialize_((char *)m);
}

void *test_activate(void *m, const void *x) {
  return _activate_((char *)m, (const float *)x);
}

void test_train(void *m, const void *x, const void *y) {
  _train_((char *)m, (const float *)x, (const float *)y);
}

