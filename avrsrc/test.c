/*
 * Auto Generated by The Gravity Compiler - Fri Jun 26 02:13:00 2020
 * Copyright (C) Tony Givargis, 2019-2020
 */

#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <math.h>
#include "test.h"
#include "avr-sim.h"

static void _initialize_() {
  { /* RANDOM */
    float r;
    uint32_t i;
    for (i=0; i<78400UL; ++i) {
      r = (float)rand() / RAND_MAX;
      ram_write_float(0UL + 4*i, -0.006787 + r * 0.013575);
    }
  }

  { /* CLEAR */
    ram_write(313600UL, 0, 100UL * sizeof (float));
  }

  { /* RANDOM */
    float r;
    uint32_t i;
    for (i=0; i<10000UL; ++i) {
      r = (float)rand() / RAND_MAX;
      ram_write_float(314000UL + 4*i, -0.030000 + r * 0.060000);
    }
  }

  { /* CLEAR */
    ram_write(354000UL, 0, 100UL * sizeof (float));
  }

  { /* RANDOM */
    float r;
    uint32_t i;
    for (i=0; i<1000UL; ++i) {
      r = (float)rand() / RAND_MAX;
      ram_write_float(354400UL + 4*i, -0.054545 + r * 0.109091);
    }
  }

  { /* CLEAR */
    ram_write(358400UL, 0, 10UL * sizeof (float));
  }

  { /* RET */
    return;
  }
}

static float *_activate_(const float *x_) {
  { /* COPYX */
    ram_cpy(716880UL, x_, 784UL * sizeof (float));
  }

  { /* MAC1 */
    uint32_t i, j;
    for (i=0; i<100UL; ++i) {
      ram_write_float(720016UL + 4*i, 0.0);
      for (j=0; j<784UL; ++j) {
        const float A = ram_read_float(0UL + 4*(i * 784UL + j));
        const float B = ram_read_float(716880UL + 4*j);
        ram_inc_float(720016UL + 4*i, A * B);
      }
    }
  }

  { /* ADD */
    uint32_t i;
    for (i=0; i<100UL; ++i) {
      const float B = ram_read_float(313600UL + 4*i);
      ram_inc_float(720016UL + 4*i, B);
    }
  }

  { /* RELU */
    uint32_t i;
    for (i=0; i<100UL; ++i) {
      float za = ram_read_float(720016UL + 4*i);
      if (0.0 >= za) {
        ram_write_float(720016UL + 4*i, 0.0);
      }
    }
  }

  { /* MAC1 */
    uint32_t i, j;
    for (i=0; i<100UL; ++i) {
      ram_write_float(720816UL + 4*i, 0.0);
      for (j=0; j<100UL; ++j) {
        const float A = ram_read_float(314000UL + 4*(i * 100UL + j));
        const float B = ram_read_float(720016UL + 4*j);
        ram_inc_float(720816UL + 4*i, A * B);
      }
    }
  }

  { /* ADD */
    uint32_t i;
    for (i=0; i<100UL; ++i) {
      const float B = ram_read_float(354000UL + 4*i);
      ram_inc_float(720816UL + 4*i, B);
    }
  }

  { /* RELU */
    uint32_t i;
    for (i=0; i<100UL; ++i) {
      float za = ram_read_float(720816UL + 4*i);
      if (0.0 >= za) {
        ram_write_float(720816UL + 4*i, 0.0);
      }
    }
  }

  { /* MAC1 */
    uint32_t i, j;
    for (i=0; i<10UL; ++i) {
      ram_write_float(721616UL + 4*i, 0.0);
      for (j=0; j<100UL; ++j) {
        const float A = ram_read_float(354400UL + 4*(i * 100UL + j));
        const float B = ram_read_float(720816UL + 4*j);
        ram_inc_float(721616UL + 4*i, A * B);
      }
    }
  }

  { /* ADD */
    uint32_t i;
    for (i=0; i<10UL; ++i) {
      const float B = ram_read_float(358400UL + 4*i);
      ram_inc_float(721616UL + 4*i, B);
    }
  }

  { /* SOFTMAX */
    float max=ram_read_float(721616UL), sum=0.0;
    uint32_t i;
    for (i=1; i<10UL; ++i) {
    float za = ram_read_float(721616UL + 4*i);
      if (max < za) {
        max = za;
      }
    }
    float *za_arr = malloc(sizeof(float) * 10UL);
    for (i=0; i<10UL; ++i) {
      ram_inc_float(721616UL + 4*i, -max);
      za_arr[i] = ram_read_float(721616UL + 4*i);
      sum += (float)exp(za_arr[i]);
    }
    for (i=0; i<10UL; ++i) {
      ram_write_float(721616UL + 4*i, (float)exp(za_arr[i]) / sum);
    }
  }

  { /* RETARG */
    float *ret_arr = malloc(sizeof (float) * 10UL);

    for(int i=0; i<10UL; ++i)
      ret_arr[i] = ram_read_float(721616UL + 4*i);
    return ret_arr;
  }
}

static void _backprop_(const float *y_) {
  { /* SUBY */
    uint32_t i;
    for (i=0; i<10UL; ++i) {
      const float A = ram_read_float(721616UL + 4*i);
      ram_write_float(721656UL + 4*i, A - y_[i]);
    }
  }

  { /* MAC2 */
    uint32_t i, j;
    for (i=0; i<100UL; ++i) {
      ram_write_float(721216UL + 4*i, 0.0);
      for (j=0; j<10UL; ++j) {
        const float A = ram_read_float(354400UL + 4*(j * 100UL + i));
        const float B = ram_read_float(721656UL + 4*j);
        ram_inc_float(721216UL + 4*i, A * B);
      }
    }
  }

  { /* RELUD */
    uint32_t i;
    for (i=0; i<100UL; ++i) {
      const float B = ram_read_float(720816UL + 4*i);
      if (0.0 >= B) {
        ram_write_float(721216UL + 4*i, 0.0);
      }
    }
  }

  { /* MAC2 */
    uint32_t i, j;
    for (i=0; i<100UL; ++i) {
      ram_write_float(720416UL + 4*i, 0.0);
      for (j=0; j<100UL; ++j) {
        const float A = ram_read_float(314000UL + 4*(j * 100UL + i));
        const float B = ram_read_float(721216UL + 4*j);
        ram_inc_float(720416UL + 4*i, A * B);
      }
    }
  }

  { /* RELUD */
    uint32_t i;
    for (i=0; i<100UL; ++i) {
      const float B = ram_read_float(720016UL + 4*i);
      if (0.0 >= B) {
        ram_write_float(720416UL + 4*i, 0.0);
      }
    }
  }

  { /* ADD */
    uint32_t i;
    for (i=0; i<100UL; ++i) {
      const float B = ram_read_float(720416UL + 4*i);
      ram_inc_float(672040UL + 4*i, B);
    }
  }

  { /* MAC3 */
    uint32_t i, j;
    for (i=0; i<100UL; ++i) {
      for (j=0; j<784UL; ++j) {
        const float B = ram_read_float(720416UL + 4*i);
        const float C = ram_read_float(716880UL + 4*j);
        ram_inc_float(358440UL + 4*(i * 784UL + j), B * C);
      }
    }
  }

  { /* ADD */
    uint32_t i;
    for (i=0; i<100UL; ++i) {
      const float B = ram_read_float(721216UL + 4*i);
      ram_inc_float(712440UL + 4*i, B);
    }
  }

  { /* MAC3 */
    uint32_t i, j;
    for (i=0; i<100UL; ++i) {
      for (j=0; j<100UL; ++j) {
        const float B = ram_read_float(721216UL + 4*i);
        const float C = ram_read_float(720016UL + 4*j);
        ram_inc_float(672440UL + 4*(i * 100UL + j), B * C);
      }
    }
  }

  { /* ADD */
    uint32_t i;
    for (i=0; i<10UL; ++i) {
      const float B = ram_read_float(721656UL + 4*i);
      ram_inc_float(716840UL + 4*i, B);
    }
  }

  { /* MAC3 */
    uint32_t i, j;
    for (i=0; i<10UL; ++i) {
      for (j=0; j<100UL; ++j) {
        const float B = ram_read_float(721656UL + 4*i);
        const float C = ram_read_float(720816UL + 4*j);
        ram_inc_float(712840UL + 4*(i * 100UL + j), B * C);
      }
    }
  }

  { /* RET */
    return;
  }
}

static void _train_(const float *x_, const float *y_) {
  { /* CLEAR */
    ram_write(358440UL, 0, 89610UL * sizeof (float));
  }

  { /* BATCHLOOP */
    uint32_t i;
    for (i=0; i<8UL; ++i) {
        float *ret_arr = _activate_(x_ + i * 784UL);
        free(ret_arr);
        _backprop_(y_ + i * 10UL);
    }
  }

  { /* MAC4 */
    uint32_t i;
    for (i=0; i<78400UL; ++i) {
      const float B = ram_read_float(358440UL + 4*i);
      ram_inc_float(0UL + 4*i, B * -0.012500);
    }
  }

  { /* MAC4 */
    uint32_t i;
    for (i=0; i<100UL; ++i) {
      const float B = ram_read_float(672040UL + 4*i);
      ram_inc_float(313600UL + 4*i, B * -0.012500);
    }
  }

  { /* MAC4 */
    uint32_t i;
    for (i=0; i<10000UL; ++i) {
      const float B = ram_read_float(672440UL + 4*i);
      ram_inc_float(314000UL + 4*i, B * -0.012500);
    }
  }

  { /* MAC4 */
    uint32_t i;
    for (i=0; i<100UL; ++i) {
      const float B = ram_read_float(712440UL + 4*i);
      ram_inc_float(354000UL + 4*i, B * -0.012500);
    }
  }

  { /* MAC4 */
    uint32_t i;
    for (i=0; i<1000UL; ++i) {
      const float B = ram_read_float(712840UL + 4*i);
      ram_inc_float(354400UL + 4*i, B * -0.012500);
    }
  }

  { /* MAC4 */
    uint32_t i;
    for (i=0; i<10UL; ++i) {
      const float B = ram_read_float(716840UL + 4*i);
      ram_inc_float(358400UL + 4*i, B * -0.012500);
    }
  }

  { /* RET */
    return;
  }
}

int test_version(void) {
  return 10;
}

size_t test_memory_size(void) {
  return 721696UL;
}

size_t test_memory_hard(void) {
  return 358440UL;
}

void test_initialize() {
  _initialize_();
}

void *test_activate(const void *x) {
  return _activate_((const float *)x);
}

void test_train(const void *x, const void *y) {
  _train_((const float *)x, (const float *)y);
}

